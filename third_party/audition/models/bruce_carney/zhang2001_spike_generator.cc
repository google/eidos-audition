// Copyright 2001 Xuedong Zhang
// Copyright 2019 Google LLC
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// version 2 as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

#include "third_party/audition/models/bruce_carney/zhang2001_spike_generator.h"

#include <cstdlib>
#include <cmath>

#include "eidos/port/logging.h"

namespace eidos {
namespace audition {
namespace {

// Dead time or absolute refractory period (sec).
constexpr double kDeadTime = 0.75E-3;

// Relative refractory parameters:
//
// According to Zhang and Carney (2001), following spike history parameters for
// two exponents fit
//   - Westerman and Smith (1989): "A diffusion model of the transient response
//     of the cochlear inner hair cell synapse."., JASA, vol. 83, no. 6.
//   - Gaumond and Kim (1983): "Response of cochlear nerve fibers to brief
//     acoustic stimuli: Role of discharge‐history effects.", JASA,
//     vol. 74, no. 5.
constexpr double kC0 = 0.5;     // Dimensionless.
constexpr double kS0 = 0.001;   // sec
constexpr double kC1 = 0.5;     // Dimensionless.
constexpr double kS1 = 0.0125;  // sec

// This is the spike generator including refractoriness, the spikes
// are generated by nonhemogeneous process. The average rate is
// modified by the synapse output simutaneously.  The probability of
// the spike generating is also affected by the synapse history as
// absolute and relative refractoriness.
class SpikeGenerator {
 public:
  SpikeGenerator(double sample_period, double dead_time) {
    time_t seed;
    seed = std::time(NULL);
    std::srand(seed);
    dead_time_ = dead_time;
    sample_period_ = sample_period;
    cur_time_ = 0.0; spike_time_ = 0.0;
  }

  // Resets the spike generator, simulates the situation that the
  // fiber has spontaneous rate.
  void Init(double spont) {
    if (spont > 0.0) {
      spike_time_ = cur_time_ - std::rand() / static_cast<double>(RAND_MAX) *
          1.0 / spont;
    } else {
      spike_time_ = spike_time_ - cur_time_; cur_time_ = 0;
    }
  }

  // Gets the time of spike generator.
  double GetCurrentTime() const { return cur_time_; }

  // This function generate the spikes according synapse
  // output(x=sout), also including the refractoriness.
  bool Run(double x) {
    bool spike = false;
    cur_time_ += sample_period_;  // running time
    // Interval from last spike, including 'wrap around' between trials.
    const double since_last_spike = cur_time_ - spike_time_;
    if (since_last_spike > dead_time_) {
      const double prob = x * (1.0 - (
          kC0 * std::exp(
              -(since_last_spike - dead_time_) / kS0) +
          kC1 * std::exp(
              -(since_last_spike - dead_time_) / kS1))) * sample_period_;
      if (prob > drand48()) {
        spike_time_ = cur_time_;
        spike = true;
      }
    }
    return spike;
  }

private:
  double sample_period_;  // Time resolution (in seconds).
  double cur_time_;  // Current running time (in seconds).
  double spike_time_;  // Time when the last spike happened (In seconds).
  double dead_time_;  // In seconds.
};

}  // namespace

// The logic should probably be reworked, where the number of trials becomes the
// number of fibers converging on a particular cell along the BM partition.
void Zhang2001SpikeGenerator(const Eigen::Ref<const Eigen::ArrayXXd> &input,
                             double sample_period,  // Seconds.
                             int num_repeats,  // Number of trials.
                             Eigen::ArrayXXd *output) {
  const int num_channels = input.rows();
  const int num_samples = input.cols();
  *output = Eigen::ArrayXXd::Zero(num_channels, num_samples);
  for (int i = 0; i < num_channels; ++i) {
    SpikeGenerator spike_gen(sample_period, kDeadTime);
    for (int n = 0; n < num_repeats; ++n) {
      spike_gen.Init(input(i, 0));
      for (int j = 0; j < num_samples; ++j) {
        if (spike_gen.Run(input(i, j))) {
          const double running_spike_time = spike_gen.GetCurrentTime();
          const double running_spike_sample =
              running_spike_time / sample_period;
          // The spike times are relative to the beginning of the trial.
          // Need to offset the spike by the overall elapsed time.
          const int current_sample = static_cast<int>(std::fmod(
              running_spike_sample, num_samples));
          (*output)(i, current_sample) = 1.0;
        }
      }
    }
  }
}

Zhang2001SpikeGeneratorModel::Zhang2001SpikeGeneratorModel(
    const Zhang2001SpikeGeneratorConfig &config) :
    AuditoryModel(MODEL_ZHANG_SPIKES_2001, STAGE_AUDITORY_NERVE_SYNAPSE,
                  OUTPUT_SYNAPSE_SPIKE_TIMES, false /* waveform input */),
    config_(config) {
  if (config_.num_fibers() <= 0) {
    config_.set_num_fibers(1);
  }
}

void Zhang2001SpikeGeneratorModel::Init(const StimulusConfig &stimulus_config) {
  AuditoryModel::Init(stimulus_config);
}

ChannelProperties Zhang2001SpikeGeneratorModel::GetChannelProperties() const {
  const AuditoryModel *model = previous_model();
  GOOGLE_CHECK(model != nullptr);
  return model->GetChannelProperties();
}

void Zhang2001SpikeGeneratorModel::ProcessSegment(
    const Eigen::Ref<const Eigen::ArrayXXd> &input,  // Rates.
    Eigen::ArrayXXd *output) {
  const int sample_rate = stimulus_config().sample_rate();
  GOOGLE_CHECK_LT(0, sample_rate);
  const double sample_period = 1.0 / sample_rate;
  Zhang2001SpikeGenerator(input, sample_period, config_.num_fibers(), output);
}

}  // namespace audition
}  // namespace eidos
